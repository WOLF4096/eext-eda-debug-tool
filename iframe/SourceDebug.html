<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>源码追加 Debug 工具</title>
    <style>
        /* --- 基础样式 --- */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #202020; color: #d4d4d4;
        }
        ::-webkit-scrollbar { width: 12px; height: 12px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background-color: #424242; border-radius: 6px; border: 3px solid #1e1e1e; }
        .container { display: flex; flex-direction: column; height: 100%; width: 100%; box-sizing: border-box; padding: 10px; }
        
        /* 顶部工具栏 */
        .toolbar { display: flex; justify-content: space-between; align-items: center; height: 40px; flex-shrink: 0; margin-bottom: 5px; }
        h2 { font-size: 16px; margin: 0; color: #4ec9b0; font-weight: bold; }
        
        /* 按钮组 */
        .btn-group { display: flex; gap: 10px; }
        button { color: white; border: none; padding: 5px 15px; cursor: pointer; font-size: 14px; border-radius: 3px; transition: background-color 0.2s; }
        
        /* 按钮颜色定义 */
        #btnImport { background-color: #0e639c; } /* 逐行追加 - 蓝色 */
        #btnImport:hover { background-color: #1177bb; }
        #btnImport:disabled { background-color: #555; cursor: not-allowed; }

        #btnBulk { background-color: #c05d21; } /* 全部追加 - 橙色 */
        #btnBulk:hover { background-color: #d66b2d; }
        #btnBulk:disabled { background-color: #555; cursor: not-allowed; }
        
        #btnGetSource { background-color: #3a3d41; border: 1px solid #454545; }
        #btnGetSource:hover { background-color: #4a4d51; }
        
        #btnPaste { background-color: #6c429c; } /* 紫色 */
        #btnPaste:hover { background-color: #7e5bb0; }

        /* 底部输出栏头部样式 (Label + Copy Button) */
        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end; /* 底部对齐 */
            margin-top: 10px;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        
        #btnCopy { 
            background-color: #3a3d41; border: 1px solid #454545; 
            font-size: 12px; padding: 3px 10px;
        }
        #btnCopy:hover { background-color: #4a4d51; }

        .label-text { font-size: 12px; color: #FFF; margin-bottom: 3px; }
        
        /* 输入输出框 */
        textarea { width: 100%; background-color: #252526; color: #d4d4d4; border: 1px solid #3c3c3c; outline: none; padding: 8px; box-sizing: border-box; font-family: inherit; font-size: 13px; flex: 1; white-space: pre; overflow: auto; resize: none; }
        textarea:focus { border-color: #007acc; }
        #sourceInput { margin-bottom: 0; } /* margin由output-header控制 */
        #errorOutput { color: #f48771; background-color: #2d2020; }
    </style>
</head>
<body>

<div class="container">
    <div class="toolbar">
        <h2 id="versionTitle">源码追加 Debug 工具</h2>
        <div class="btn-group">
            <button id="btnGetSource" onclick="getPrimitiveSource()" title="根据PANELIZE标记获取后续源码">获取图元源码</button>
            <button id="btnPaste" onclick="clearAndPaste()" title="清空上方输入框并粘贴剪贴板内容">清空并粘贴</button>
            <button id="btnImport" onclick="startLineByLineProcess()" title="逐行写入并检测每一行的结果">逐行追加</button>
            <button id="btnBulk" onclick="startBulkProcess()" title="将当前源码与输入框内容合并后一次性写入">全部追加</button>
        </div>
    </div>

    <div class="label-text">粘贴要追加的代码:</div>
    <textarea id="sourceInput" placeholder="在此粘贴需要追加的图元源码..."></textarea>

    <div class="output-header">
        <div class="label-text">处理结果:</div>
        <button id="btnCopy" onclick="copyErrorLog()" title="复制下方结果框的内容">复制输出结果</button>
    </div>
    <textarea id="errorOutput" placeholder="结果将显示在这里..." readonly></textarea>
</div>

<script>
    const elSourceInput = document.getElementById('sourceInput');
    const elErrorOutput = document.getElementById('errorOutput');
    const elBtnImport = document.getElementById('btnImport');
    const elBtnBulk = document.getElementById('btnBulk');
    const elBtnCopy = document.getElementById('btnCopy');

    // --- 功能：清空并粘贴 ---
    async function clearAndPaste() {
        try {
            const text = await navigator.clipboard.readText();
            elSourceInput.value = text;
            elSourceInput.focus();
            if(window.eda && eda.sys_Message) eda.sys_Message.showToastMessage("已清空并粘贴剪贴板内容", "success");
        } catch (err) {
            console.error(err);
            if(window.eda && eda.sys_Message) eda.sys_Message.showToastMessage("无法读取剪贴板，请手动粘贴", "error");
        }
    }

    // --- 功能：获取图元源码 ---
    async function getPrimitiveSource() {
        elErrorOutput.value = "正在获取源码...";
        elErrorOutput.style.color = "#d4d4d4";

        try {
            // 1. 获取版本
            const version = await eda.sys_Environment.getEditorCurrentVersion();
            const isV3 = version.startsWith('3.');
            
            // 2. 获取全量源码
            const fullSource = await eda.sys_FileManager.getDocumentSource();
            
            if (!fullSource) {
                elErrorOutput.value = "当前文档为空或无法获取源码。";
                return;
            }

            const lines = fullSource.split(/\r?\n/);
            let splitIndex = -1;

            // 3. 根据版本查找特征行
            if (isV3) {
                // V3: 查找 {"type":"PANELIZE"...}
                splitIndex = lines.findIndex(line => line.includes('{"type":"PANELIZE",'));
            } else {
                // V2: 查找 ["PANELIZE_SIDE",...]
                splitIndex = lines.findIndex(line => line.includes('["PANELIZE",')) + 4;
            }

            if (splitIndex === -1) {
                elErrorOutput.value = isV3 
                    ? `未在源码中找到 "PANELIZE" 标记，无法自动截取。` 
                    : `未在源码中找到 "PANELIZE_SIDE" 标记，无法自动截取。`;
                return;
            }

            // 4. 获取标记行之后的所有数据
            const filteredLines = lines.slice(splitIndex + 1);
            
            if (filteredLines.length === 0) {
                elErrorOutput.value = `找到标记行 (行号 ${splitIndex + 1})，但其后没有数据。`;
                return;
            }

            const resultText = filteredLines.join('\n');
            elErrorOutput.value = resultText;
            elErrorOutput.scrollTop = 0;
            
            eda.sys_Message.showToastMessage(`已获取源码 (从第 ${splitIndex + 2} 行开始)`, "success");

        } catch (err) {
            console.error(err);
            elErrorOutput.style.color = "#f48771";
            elErrorOutput.value = `[获取失败]: ${err.message}`;
        }
    }

    async function copyErrorLog() {
        const content = elErrorOutput.value;
        if (!content) {
            eda.sys_Message.showToastMessage("没有可复制的内容","info");
            return;
        }
        try {
            await navigator.clipboard.writeText(content);
            showCopyFeedback();
        } catch (err) {
            elErrorOutput.select();
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            elErrorOutput.blur(); 
            showCopyFeedback();
        }
    }

    function showCopyFeedback() {
        const originalText = elBtnCopy.innerText;
        elBtnCopy.innerText = "已复制";
        elBtnCopy.style.backgroundColor = "#2da042";
        setTimeout(() => {
            elBtnCopy.innerText = originalText;
            elBtnCopy.style.backgroundColor = "";
        }, 1500);
    }

    // --- 核心修复：全部追加 (一次性写入) ---
    async function startBulkProcess() {
        const inputCode = elSourceInput.value.trim();
        if (!inputCode) {
            eda.sys_Message.showToastMessage("请先输入要追加的代码！","info");
            return;
        }

        elErrorOutput.value = "正在处理全部追加...";
        elErrorOutput.style.color = "#d4d4d4";
        setButtonsDisabled(true);

        try {
            const version = await eda.sys_Environment.getEditorCurrentVersion();
            const isV3 = version.startsWith('3.');
            let currentBaseSource = await eda.sys_FileManager.getDocumentSource();
            
            let finalSource = "";

            if (isV3) {
                // --- V3 严格处理逻辑 ---
                
                // 1. 处理基础源码 (Base)
                // 如果基础源码最后没有 |，则加上 |，作为连接符
                if (currentBaseSource && currentBaseSource.trim() !== "") {
                    // 移除末尾可能的空白字符，确保判断准确
                    let tempBase = currentBaseSource.trimEnd(); 
                    if (!tempBase.endsWith('|')) {
                        tempBase += "|";
                    }
                    currentBaseSource = tempBase;
                }

                // 2. 处理待追加源码 (Input)
                // 先分割行，过滤空行
                const inputLines = inputCode.split(/\r?\n/).filter(l => l.trim() !== "");
                
                // 3. 清洗输入行：把所有行的末尾 | 都去掉
                const sanitizedLines = inputLines.map(line => {
                    let l = line.trim();
                    if (l.endsWith('|')) {
                        l = l.slice(0, -1);
                    }
                    return l;
                });

                // 4. 重新拼接：用 "|\n" 连接
                // 效果：Line1|\nLine2|\nLine3
                // 这样最后一行Line3后面绝对没有 |
                const processedInputBlock = sanitizedLines.join('|\n');

                // 5. 最终合并
                // 基础源码(已补|) + 换行 + 处理后的新块(无末尾|)
                if (!currentBaseSource || currentBaseSource.trim() === "") {
                    finalSource = processedInputBlock;
                } else {
                    finalSource = currentBaseSource + "\n" + processedInputBlock;
                }

            } else {
                // --- V2 处理逻辑 ---
                const separator = currentBaseSource.endsWith('\n') ? "" : "\n";
                finalSource = currentBaseSource + separator + inputCode;
            }

            // 6. 写入 EDA
            const isSuccess = await eda.sys_FileManager.setDocumentSource(finalSource);

            if (isSuccess) {
                elErrorOutput.style.color = "#4ec9b0"; 
                elErrorOutput.value = "蒸蚌！全部追加成功！";
                if(window.eda && eda.sys_Message) eda.sys_Message.showToastMessage("全部追加成功", "success");
            } else {
                elErrorOutput.style.color = "#f48771";
                elErrorOutput.value = "\n萝卜！萝卜！萝卜！";
            }

        } catch (err) {
            console.error(err);
            elErrorOutput.value = `[系统错误]: ${err.message}`;
        } finally {
            setButtonsDisabled(false);
        }
    }

    // --- 核心修复：二分法/分块追加 (带停止功能 & UI优化) ---
    async function startLineByLineProcess() {
        const inputCode = elSourceInput.value.trim();
        if (!inputCode) {
            eda.sys_Message.showToastMessage("请先输入要追加的代码！", "info");
            return;
        }

        // --- 1. 状态与UI初始化 ---
        let stopRequested = false; // 停止标志位

        // 备份 "全部追加" 按钮的原始状态
        const originalBulkText = elBtnBulk.innerText;
        const originalBulkColor = elBtnBulk.style.backgroundColor;
        const originalBulkOnClick = elBtnBulk.onclick;

        // 修改 "全部追加" 按钮为 "停止" 按钮
        elBtnBulk.innerText = "停止";
        elBtnBulk.style.backgroundColor = "#c93c3c"; // 红色警示
        elBtnBulk.onclick = function() {
            stopRequested = true;
            elBtnBulk.innerText = "正在停止...";
            elBtnBulk.disabled = true; // 防止重复点击
        };

        // 禁用当前按钮(逐行)，启用停止按钮
        elBtnImport.disabled = true;
        elBtnBulk.disabled = false;

        elErrorOutput.value = "";
        elErrorOutput.style.color = "#f48771";
        
        let allLines = inputCode.split(/\r?\n/).filter(l => l.trim() !== "");
        let errorLog = "";
        let errorCount = 0;

        try {
            // --- 2. 环境初始化 ---
            const version = await eda.sys_Environment.getEditorCurrentVersion();
            const isV3 = version.startsWith('3.');
            let currentBaseSource = await eda.sys_FileManager.getDocumentSource();

            if (isV3 && currentBaseSource && currentBaseSource.trim() !== "") {
                if (!currentBaseSource.trimEnd().endsWith('|')) {
                    currentBaseSource = currentBaseSource.trimEnd() + "|";
                }
            }

            // --- 3. 设定初始块大小 ---
            let chunkSize = (allLines.length < 256) ? 1 : 1024;
            let currentQueue = allLines;

            // --- 4. 循环处理 ---
            while (currentQueue.length > 0) {
                // [检测停止]：如果在循环开始前按下了停止
                if (stopRequested) {
                    elErrorOutput.value += "\n\n[用户操作]: 已手动停止追加任务。";
                    break;
                }

                let nextPassQueue = [];
                
                // [UI 更新]：双行显示，字体变小 (12px)，行高紧凑
                elBtnImport.innerHTML = `
                    <div style="font-size: 11px; line-height: 1.2; display: flex; flex-direction: column; align-items: center;">
                        <span>${chunkSize} 行/次</span>
                        <span>剩余: ${currentQueue.length}</span>
                    </div>
                `;
                
                // 遍历当前队列
                for (let i = 0; i < currentQueue.length; i += chunkSize) {
                    // [检测停止]：如果在循环过程中按下了停止
                    if (stopRequested) {
                        break;
                    }

                    const chunkLines = currentQueue.slice(i, i + chunkSize);
                    const success = await tryAppendChunk(currentBaseSource, chunkLines, isV3);

                    if (success) {
                        currentBaseSource = success.newSource;
                    } else {
                        if (chunkSize === 1) {
                            errorCount++;
                            errorLog += `${chunkLines[0]}\n`;
                            elErrorOutput.value = errorLog;
                            elErrorOutput.scrollTop = elErrorOutput.scrollHeight;
                        } else {
                            nextPassQueue.push(...chunkLines);
                        }
                    }
                    
                    // 防卡顿
                    if (i % (chunkSize * 5) === 0) await new Promise(r => setTimeout(r, 0)); 
                }

                if (stopRequested || chunkSize === 1) break;
                
                currentQueue = nextPassQueue;
                chunkSize = Math.max(1, Math.floor(chunkSize / 2));
            }

            // --- 5. 结果显示 ---
            if (!stopRequested) {
                if (errorCount === 0) {
                    elErrorOutput.style.color = "#4ec9b0";
                    elErrorOutput.value = "蒸蚌！全部追加成功！(无报错)";
                    if (window.eda) eda.sys_Message.showToastMessage("追加完成", "success");
                } else {
                    elErrorOutput.style.color = "#f48771";
                    elErrorOutput.value = errorLog + `\n------------------\n共发现 ${errorCount} 行错误代码`;
                    if (window.eda) eda.sys_Message.showToastMessage(`发现 ${errorCount} 个错误`, "error");
                }
            }

        } catch (err) {
            console.error(err);
            elErrorOutput.value += `\n[系统异常]: ${err.message}`;
        } finally {
            // --- 6. 恢复 UI 状态 ---
            elBtnImport.disabled = false;
            elBtnImport.innerText = "逐行追加"; // 恢复原始文字
            
            // 恢复 "全部追加" 按钮
            elBtnBulk.onclick = originalBulkOnClick;
            elBtnBulk.innerText = originalBulkText;
            elBtnBulk.style.backgroundColor = ""; // 清空内联样式，恢复CSS默认
            elBtnBulk.disabled = false;
        }
    }

    /**
     * 辅助函数：尝试追加一个代码块
     * 返回对象 { newSource: string } 表示成功，返回 false 表示失败
     */
    async function tryAppendChunk(baseSource, lines, isV3) {
        let candidateSource = "";
        
        if (isV3) {
            // V3逻辑：
            // 1. 清理块中每一行的末尾 |
            const sanitizedBlock = lines.map(line => line.trim().endsWith('|') ? line.trim().slice(0, -1) : line.trim());
            // 2. 用 |\n 连接
            const blockStr = sanitizedBlock.join('|\n');
            // 3. 拼接到 Base (Base此时应该已有末尾的 |)
            candidateSource = baseSource + "\n" + blockStr;
        } else {
            // V2逻辑：直接换行拼接
            const separator = baseSource.endsWith('\n') ? "" : "\n";
            const blockStr = lines.join('\n');
            candidateSource = baseSource + separator + blockStr;
        }

        const isSuccess = await eda.sys_FileManager.setDocumentSource(candidateSource);
        
        if (isSuccess) {
            // 成功后，为了下一次追加，V3需要补上末尾的 |
            if (isV3) {
                candidateSource += "|";
            }
            return { newSource: candidateSource };
        } else {
            return false;
        }
    }

    function setButtonsDisabled(disabled) {
        elBtnImport.disabled = disabled;
        elBtnBulk.disabled = disabled;
    }
</script>
</body>
</html>
